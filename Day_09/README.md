# Содержание

- [Задание 00: Я знаю Кунг-Фу](#упражнение-00-я-знаю-кунг-фу)
- [Упражнение 01: Кальмар на палочке](#упражнение-01-кальмар-на-палочке)
- [Упражнение 02: Дежа Вю](#упражнение-02-дежа-вю)

### Упражнение 00: Всё ещё считает

Вам нужно написать простой модуль калькулятора для Python (с использованием Python C API) с четырьмя функциями:

- `add(a, b)`
- `sub(a, b)`
- `mul(a, b)`
- `div(a, b)`

Этот модуль должен состоять из двух файлов - 'calculator.c' и 'setup.py' для сборки его.
В обычной части EX00 предположим, что числа являются целыми:

```python
>> > import calculator
>> > calculator.add(14.5, 21.87)
Traceback(most
recent
call
last):
File
"<stdin>", line
1, in < module >
TypeError: integer
argument
expected, got
float
>> > calculator.add(14, 21)
35
>> > calculator.sub(14, 21)
-7
>> > calculator.mul(14, 21)
294
>> > calculator.div(14, 7)
2
```

Также, ваш код должен правильно обрабатывать ошибки деления на ноль, вызывая встроенное исключение Python из C-кода:

```python
>> > calculator.div(14, 0)
Traceback(most
recent
call
last):
File
"<stdin>", line
1, in < module >
ZeroDivisionError: integer
division or modulo
by
zero
```

Модуль должен состоять только из двух упомянутых выше файлов и быть устанавливаемым с помощью

``` bash
python setup.py install
```

БОНУС: улучшите код вашего калькулятора, чтобы он мог обрабатывать как целые, так и вещественные значения для обоих
операндов.

### Упражнение 01: Разделённая секунда

Вам нужно использовать встроенную библиотеку `ctypes` в Python, чтобы реализовать интерфейс к монотонному
часам в вашей операционной системе. Windows, Linux и MacOS имеют эту функцию как часть стандартной
библиотеки. Python [также имеет её теперь](https://peps.python.org/pep-0418/#time-monotonic), но вы
должны написать свою собственную версию с нуля.

Это должна быть функция `monotonic()` в файле `monotonic.py`, и возвращаемое значение должно быть в секундах (некоторые
ОС также поддерживают наносекунды).

### Упражнение 02: Автопилот

В этом упражнении вам нужно использовать третий способ ускорения вычислений в Python, который
называется [Cython](https://cython.org/).
Мы не входим в область данных, но умножение матриц является очень простым и прямым процессом.

Пример простой Python-кода для этого может выглядеть примерно так:

```python
from itertools import tee


def mul(a, b):
    b_iter = tee(zip(*b), len(a))


return [
    [
        sum(ele_a * ele_b for ele_a, ele_b in zip(row_a, col_b))
        for col_b in b_iter[i]
    ] for i, row_a in enumerate(a)
]
```

Ваша задача - написать свою собственную функцию mul() в Cython (имя файла multiply.pyx) и реализовать правильный файл
setup.py для создания пакета Python под названием 'matrix':

Ваша функция должна уметь умножать матрицы, используя только целые числа, и работать с матрицами размером не более
100x100.

Также вам нужно написать тест производительности в файле test_mul_perf.py, сравнивающий базовую реализацию на чистом
Python с вашей реализацией на Cython. Он должен быть значительно быстрее.