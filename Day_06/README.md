# Содержание

- [Задание 00: Отчетность Кирова](#задание-00-отчетность-кирова)
- [Упражнение 01: Проверка качества данных](#упражнение-01-проверка-качества-данных)
- [Упражнение 02: Сохранение отчетов](#упражнение-02-сохранение-отчетов)

## Задание 00: Отчетность Кирова

Каждый космический корабль имел несколько характеристик:

* Выравнивание (Союзник/Враг)
* Имя (может быть "Неизвестно" для вражеских кораблей)
* Класс, который является одним из {Корвет, Фрегат, Крейсер, Эсминец, Авианосец, Дредноут}
* Длина в метрах
* Размер экипажа
* Вооруженность корабля
* Один или несколько офицеров, ответственных за корабль

Система должна состоять из трех архитектурных слоев:

* Транспортный слой
* Слой валидации
* Слой хранения

Основным протоколом, используемым для межпространственной связи, был "Protobuf 2.0". Входы передавались по транспортному
каналу "gRPC". Это был первый слой, который нужно было реализовать.

Поскольку gRPC - это клиент-серверный фреймворк связи, необходимо было реализовать два компонента - "
reporting_server.py" и "reporting_client.py". Сервер должен был предоставить потоковый конечный пункт, где он получал
набор координат (разрешалось использовать любую систему), и отвечал потоком записей космических кораблей.

Поскольку это было тестовое окружение, каждый космический корабль должен был иметь все параметры, упомянутые выше, но
они могли быть случайными. Кроме того, они должны были быть строго типизированными, например:

* Выравнивание - это перечисление
* Имя - это строка
* Длина - это число с плавающей точкой
* Класс - это перечисление
* Размер - это целое число
* Вооруженность - это логическое значение
* Каждый офицер на борту должен иметь имя, фамилию и звание как строки

Количество офицеров на борту было случайным числом от 0 (только для вражеских кораблей) до 10.

Работа должна была происходить следующим образом:

* Сервер запускался
* Клиент запускался с набором координат в некотором выбранном формате, например:

 ``` bash
~$ ./reporting_client.py 17 45 40.0409 -29 00 28.118
```

−29 00 28.118

* Эти координаты отправлялись на сервер, и сервер отвечал случайным (1-10) числом космических кораблей в потоке gRPC
  клиенту
* Клиент выводил на стандартный вывод все полученные корабли как набор сериализованных строк JSON, например:
  ``` json
  {
    "alignment": "Ally",
    "name": "Normandy",
    "class": "Corvette",
    "length": 216.3,
    "crew_size": 8,
    "armed": true,
    "officers": [
      {
        "first_name": "Alan",
        "last_name": "Shepard",
        "rank": "Commander"
      }
    ]
  }
  {
    "alignment": "Enemy",
    "name": "Executor",
    "class": "Dreadnought",
    "length": 19000.0,
    "crew_size": 450,
    "armed": true,
    "officers": []
  }
   ```

## Упражнение 01: Проверка качества данных

| Класс        | Длина      | Экипаж  | Может быть вооружен? | Может быть враждебным? |
|--------------|------------|---------|----------------------|------------------------|
| Корвета      | 80-250     | 4-10    | Да                   | Да                     |
| Фрегат       | 300-600    | 10-15   | Да                   | Нет                    |
| Крейсер      | 500-1000   | 15-30   | Да                   | Да                     |
| Уничтожитель | 800-2000   | 50-80   | Да                   | Нет                    |
| Авианосец    | 1000-4000  | 120-250 | Нет                  | Да                     |
| Дредноут     | 5000-20000 | 300-500 | Да                   | Да                     |

Требования:

- проверить поток космических кораблей с использованием Pydantic
- отфильтровать те, у которых некоторые параметры выходят за пределы таблицы выше
- остальные должны быть напечатаны точно так же, как в EX00
- имя может быть "Неизвестным" ТОЛЬКО для враждебных кораблей

## Упражнение 02: Сохранение отчетов

Теперь проект Эндера должен включать скрипт "reporting_client_v3.py", который отвечает за сопоставление входящих
объектов с базой данных через ORM.

Третья версия клиента должна не только выводить отфильтрованный список космических кораблей, но и сохранять их в базе
данных PostgreSQL.

Другой случай, который полковник попросил Эндера реализовать, - это поиск "предателей". Иногда одни и те же офицеры (с
уникальной комбинацией имени, фамилии и звания) могут быть обнаружены как на союзных, так и на вражеских кораблях.

```bash
~$ ./reporting_client_v3.py scan 17 45 40.0409  -29 00 28.118
```

А список предателей будет

```bash
~$ ./reporting_client.py list_traitors
```

который должен выводить список строк JSON с именами "предателей":

```json
{
  "first_name": "Lando",
  "last_name": "Calrissian",
  "rank": "Entrepreneur"
}
{
  "first_name": "Red",
  "last_name": "Guy",
  "rank": "Impostor"
}
```

**Дополнительное задание (Бонус)**

Используйте Alembic для генерации миграций базы данных и добавления поля "скорость" в модель космического корабля.

**Описание задания**

1. **Создайте скрипт "reporting_client_v3.py"**, который будет отвечать за сохранение отчетов в базе данных PostgreSQL.
2. **Реализуйте интерфейс сканирования** для поиска предателей.
3. **Добавьте возможность вывода списка предателей**.
4. **Используйте Alembic** для генерации миграций для инициализации базы данных и добавления необязательного поля "
   скорость" в модель космического корабля.